---
date: 2026-01-17 10:18:59 PST
researcher: claude
git_commit: 343ab540f013d222150301c9670701f5d2dcb4dd
branch: master
repository: bevy-lightyear-template
topic: "How to save and load the voxel world on the server"
tags: [research, codebase, voxel-world, save-load, persistence, server]
status: complete
last_updated: 2026-01-17
last_updated_by: claude
---

# Research: How to save and load the voxel world on the server

**Date**: 2026-01-17 10:18:59 PST
**Researcher**: claude
**Git Commit**: 343ab540f013d222150301c9670701f5d2dcb4dd
**Branch**: master
**Repository**: bevy-lightyear-template

## Research Question

How to save and load the voxel world on the server?

## Summary

The server currently has **no persistence system** - all voxel world state exists only in memory and is lost on server restart. The system tracks voxel modifications in a `VoxelModifications` resource containing a `Vec<(IVec3, VoxelType)>` of all edits. The procedural terrain base (flat below y=0) is deterministic and doesn't need saving. To implement persistence, the modifications vector needs to be serialized to disk on save and deserialized on load, then applied to both the `VoxelModifications` resource and the `VoxelWorld<MapWorld>` system.

## Detailed Findings

### Current Voxel World Architecture

**Two-Layer System:**
- **Procedural base**: Generated via `voxel_lookup_delegate` (flat terrain with solid voxels below y=0)
- **Modification layer**: All voxel edits tracked in `VoxelModifications` resource

**Server Integration** (`crates/server/src/map.rs`):
- Adds `VoxelWorldPlugin::<MapWorld>` to server app
- Single headless camera at (0, 10, 0) for chunk management
- No rendering (server-side chunk spawning only)
- Chunks spawn within 2-chunk radius based on camera position

### Data Structures for Persistence

**VoxelModifications Resource** (`crates/server/src/map.rs:31-35`):
```rust
#[derive(Resource, Default)]
struct VoxelModifications {
    modifications: Vec<(IVec3, VoxelType)>,
}
```

This is the **only data that needs persistence**. It contains:
- All voxel edits as world-space position + voxel type pairs
- Append-only vector (unbounded growth during runtime)
- Cloned and sent to new clients on connection via `VoxelStateSync` message

**VoxelType Enum** (`crates/protocol/src/map.rs:36-59`):
- Already has `Serialize` and `Deserialize` derives
- Network-serializable for lightyear protocol
- Converts to/from bevy_voxel_world's `WorldVoxel<u8>` type

### Voxel Modification Flow

**Edit Request** (`crates/server/src/map.rs:36-103`):
1. Client sends `VoxelEditRequest` message
2. Server receives via `MessageReceiver<VoxelEditRequest>`
3. Server applies: `voxel_world.set_voxel(request.position, request.voxel.into())`
4. Server appends to `VoxelModifications.modifications` vector
5. Server broadcasts `VoxelEditBroadcast` to all clients

**Initial State Sync** (`crates/server/src/map.rs:105-118`):
- Observer triggers on `Add<Connected>` component
- Server sends `VoxelStateSync` containing full `VoxelModifications` vector clone
- Client applies all modifications to local voxel world

### bevy_voxel_world Internal State

**ModifiedVoxels Resource** (`git/bevy_voxel_world/src/voxel_world_internal.rs:57-75`):
- Internal resource: `Arc<RwLock<HashMap<IVec3, WorldVoxel<I>>>>`
- Maps world-space voxel positions to voxel values
- Persists across chunk lifecycle (chunks can despawn and respawn)
- Checked during chunk generation before calling `voxel_lookup_delegate`

**Chunk Lifecycle**:
- Chunks spawn within 2-chunk radius of camera/targets
- Chunks despawn when beyond spawning distance
- On respawn, voxels are regenerated by:
  1. First checking `ModifiedVoxels` map
  2. Then calling `voxel_lookup_delegate` for unmodified voxels
- This means modifications persist even after chunk despawns

### Existing Serialization Patterns

**Network Serialization** (`crates/protocol/src/map.rs:61-79`):
```rust
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Reflect, Message)]
pub struct VoxelStateSync {
    pub modifications: Vec<(IVec3, VoxelType)>,
}
```

Currently used for:
- Sending voxel state over lightyear network protocol
- Initial sync to connecting clients
- Uses serde for serialization

**No File I/O Found**:
- No file reading/writing operations in project code
- No database backends
- No `DynamicScene` usage
- No custom `AssetLoader` implementations

**Available Dependencies**:
- `serde` with derive features in workspace
- `bevy_voxel_world` with serde feature enabled
- `serde_json` in dev-dependencies (protocol crate)

### What Needs to be Saved

**Essential Data:**
- `VoxelModifications.modifications: Vec<(IVec3, VoxelType)>`
- Format version number for future compatibility

**Does NOT need saving:**
- Procedural terrain (deterministic from `voxel_lookup_delegate`)
- Chunk entities/meshes (regenerated on load)
- bevy_voxel_world's `ModifiedVoxels` (rebuilt from our modifications)
- Player positions or game state (separate concern)

### Load Process Requirements

**On Server Startup**:
1. Deserialize modifications from disk
2. Populate `VoxelModifications` resource
3. Apply each modification to `VoxelWorld<MapWorld>` via `set_voxel()`:
   - This populates bevy_voxel_world's internal `ModifiedVoxels` map
   - Ensures modifications persist across chunk spawning/despawning

**Timing**: Must happen in `PreStartup` schedule before:
- Chunks begin spawning
- Clients can connect
- Any game systems access voxel data

### Integration Points

**Files That Would Need Modification**:

1. **`crates/server/src/map.rs`** - Core save/load implementation:
   - Add save/load functions
   - Add startup load system
   - Add save trigger system (shutdown, periodic, or on-edit)
   - Register systems in `ServerMapPlugin::build()`

2. **`crates/server/Cargo.toml`** - Add dependencies:
   - File format library (bincode, serde_json, or ron)

3. **`.gitignore`** - Prevent committing save files:
   - Add save directory (e.g., `world_save/`)

**No Changes Needed**:
- `crates/protocol/src/map.rs` - `VoxelType` already has serde derives
- `crates/client/` - Client doesn't need save/load (receives from server)

## Code References

- `crates/server/src/map.rs:31-35` - VoxelModifications resource definition
- `crates/server/src/map.rs:36-103` - handle_voxel_edit_requests system
- `crates/server/src/map.rs:105-118` - send_initial_voxel_state system
- `crates/protocol/src/map.rs:36-59` - VoxelType enum with serde derives
- `crates/protocol/src/map.rs:61-79` - Network message types (VoxelStateSync)
- `crates/protocol/src/map.rs:10-33` - MapWorld configuration
- `git/bevy_voxel_world/src/voxel_world_internal.rs:57-75` - ModifiedVoxels resource
- `git/bevy_voxel_world/src/chunk.rs:393-498` - Chunk generation process

## Architecture Documentation

### Current State Management

**In-Memory Only**:
- All voxel modifications stored in RAM
- No persistence across server restarts
- State lost on crash or shutdown

**Modification Tracking**:
- Server maintains global list of all edits
- Sent to new clients on connection
- No spatial indexing or chunking
- Unbounded growth (no pruning/archival)

### Deterministic Terrain Generation

**Procedural Base**:
- `voxel_lookup_delegate` generates flat terrain (solid below y=0)
- Same configuration on client and server
- Deterministic - always produces identical terrain

**Implication for Persistence**:
- Only modifications need saving
- Procedural base regenerates on load
- Efficient for worlds with sparse edits

### Network Protocol

**Message-Based Replication**:
- Voxel edits use messages (not component replication)
- `VoxelEditRequest` (client → server)
- `VoxelEditBroadcast` (server → all clients)
- `VoxelStateSync` (server → new client)

**Channel Configuration**:
- `VoxelChannel` uses `OrderedReliable`
- Guaranteed delivery, ordered
- Bidirectional

### bevy_voxel_world Integration

**Plugin Configuration**:
- `VoxelWorldPlugin::<MapWorld>` added to server
- `MapWorld` implements `VoxelWorldConfig` trait
- Material index: `u8` (256 material types)
- Chunk size: 32×32×32 voxels
- Spawning distance: 2 chunks

**Internal State**:
- `ChunkMap<C, I>` - Active chunks in memory
- `ModifiedVoxels<C, I>` - Persistent voxel edits
- Chunks spawn/despawn based on distance
- Modifications persist across chunk lifecycle

## Historical Context (from doc/)

- `doc/research/2025-12-24-bevy-voxel-world-map-plugins.md` - Initial voxel world integration research
- `doc/research/2026-01-03-server-chunk-visibility-determination.md` - Per-client chunk visibility analysis
- `doc/research/2026-01-03-bevy-ecs-chunk-visibility-patterns.md` - Chunk visibility patterns in Bevy ECS
- `doc/plans/2025-12-24-voxel-map-plugins.md` - Planning document for voxel map plugins
- `doc/plans/2026-01-04-transform-based-chunk-visibility.md` - Chunk visibility implementation plan

## Implementation Recommendations

### Minimal Viable Implementation

1. **Data Structure**:
   ```rust
   #[derive(Serialize, Deserialize)]
   struct VoxelWorldSave {
       version: u32,
       modifications: Vec<(IVec3, VoxelType)>,
   }
   ```

2. **Save Function**:
   - Serialize `VoxelModifications` to file
   - Write to temporary file, then rename (atomic)
   - Location: `./world_save/voxel_world.*`

3. **Load Function**:
   - Read and deserialize on startup
   - Populate `VoxelModifications` resource
   - Apply to `VoxelWorld<MapWorld>` via `set_voxel()`
   - If file missing, start with empty world

4. **Save Triggers**:
   - Graceful shutdown (AppExit event)
   - Optional: Periodic (every N seconds)
   - Optional: Debounced on edit

5. **Error Handling**:
   - File not found: Start clean (normal)
   - Parse error: Log warning, backup corrupt file, start clean
   - I/O error: Log error, start clean

### Format Options

**Binary (bincode)**:
- ✓ Compact (smallest file size)
- ✓ Fast to parse
- ✗ Not human-readable

**JSON**:
- ✓ Human-readable
- ✓ Easy to debug/inspect
- ✗ Larger file size
- `serde_json` already available as dev dependency

**RON (Rust Object Notation)**:
- ✓ Human-readable
- ✓ Rust-friendly syntax
- ✓ More compact than JSON
- ✗ Requires new dependency

### Save Timing Strategies

**Option 1: Shutdown Only**:
- Simplest implementation
- No I/O during gameplay
- Risk: Data loss on crash

**Option 2: Periodic (e.g., every 60s)**:
- Predictable I/O pattern
- Limits data loss window
- May save unnecessarily

**Option 3: Debounced on Edit**:
- Save N seconds after last edit
- Minimizes I/O during active editing
- Ensures changes persist quickly

**Option 4: Immediate on Edit**:
- Maximum safety
- High I/O overhead
- May impact performance

## Implementation Decisions

**Save Timing**: Debounced with maximum dirty duration
- Debounce: Wait 1s after last voxel edit, then save
- Max dirty duration: Force save after 5s even if edits continue
- Prevents continuous editing from blocking saves indefinitely
- Also save on graceful shutdown
- Minimizes I/O while ensuring quick persistence and bounded data loss

**File Format**: Binary (bincode)
- Compact binary format
- Smallest file size, fastest to parse
- Requires adding `bincode = "1.3"` dependency

**Error Recovery**: Start with empty world on corrupt file
- Log warning and backup corrupt file to `*.corrupt`
- Server continues running with empty world
- No service interruption, graceful degradation

## Future Considerations

- **Multiple worlds**: Currently single world only, could add world name parameter
- **Async I/O**: Currently blocking, could move to async for better performance
- **Backup rotation**: Keep last N saves for safety
- **Compression**: Add gzip/zstd if file size becomes an issue
- **Migration**: Implement version-based migration when format changes
